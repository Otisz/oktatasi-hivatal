---
phase: 02-routing-and-data-layer
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/composables/useApplicants.ts
  - src/composables/useApplicantScore.ts
autonomous: true
requirements: [DATA-02, DATA-03, DATA-04]

must_haves:
  truths:
    - "useApplicants composable returns a typed Applicant[] array from TanStack Query"
    - "useApplicantScore composable returns a typed ScoreResult from TanStack Query"
    - "A 422 API response is captured as a domain error (kind: 'domain') with the verbatim Hungarian message"
    - "A network/5xx error is captured as a generic error (kind: 'generic')"
    - "422 domain errors are NOT retried by TanStack Query (deterministic errors)"
    - "Generic errors are retried by TanStack Query (transient failures)"
  artifacts:
    - path: "src/composables/useApplicants.ts"
      provides: "TanStack Query composable for GET /api/v1/applicants"
      exports: ["useApplicants"]
    - path: "src/composables/useApplicantScore.ts"
      provides: "TanStack Query composable for GET /api/v1/applicants/{id}/score with 422 discrimination"
      exports: ["useApplicantScore", "ScoreError"]
  key_links:
    - from: "src/composables/useApplicants.ts"
      to: "src/lib/http.ts"
      via: "import { http } from '@/lib/http'"
      pattern: "http\\.get.*api/v1/applicants"
    - from: "src/composables/useApplicants.ts"
      to: "src/types/api.ts"
      via: "import type { Applicant, ApiResponse }"
      pattern: "ApiResponse<Applicant\\[\\]>"
    - from: "src/composables/useApplicantScore.ts"
      to: "src/lib/http.ts"
      via: "import { http } from '@/lib/http'"
      pattern: "http\\.get.*api/v1/applicants.*score"
    - from: "src/composables/useApplicantScore.ts"
      to: "src/types/api.ts"
      via: "import type { ApiError, ScoreResult }"
      pattern: "ScoreResult"
    - from: "src/composables/useApplicantScore.ts"
      to: "axios"
      via: "axios.isAxiosError for 422 narrowing"
      pattern: "axios\\.isAxiosError"
---

<objective>
Create two TanStack Query composables that provide typed data fetching for the applicant list and applicant score endpoints, with explicit 422 domain error discrimination in the score query.

Purpose: These composables are the data layer that Phase 3 (list view) and Phase 4 (score detail view) will consume. Building them now in isolation ensures the query logic, error typing, and caching behavior are correct before any view code touches them.

Output: `useApplicants()` composable returning `Applicant[]` and `useApplicantScore(id)` composable returning `ScoreResult` with discriminated `ScoreError` union for 422 vs generic errors.
</objective>

<execution_context>
@/Users/otisz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/otisz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-routing-and-data-layer/02-CONTEXT.md
@.planning/phases/02-routing-and-data-layer/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/types/api.ts:
```typescript
export interface Program {
  university: string
  faculty: string
  name: string
}

export interface Applicant {
  id: string
  program: Program
}

export interface ScoreResult {
  osszpontszam: number
  alappont: number
  tobbletpont: number
}

export interface ApiError {
  error: string
}

export interface ApiResponse<T> {
  data: T
}
```

From src/lib/http.ts:
```typescript
import axios from 'axios'

export const http = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  headers: {
    Accept: 'application/json',
    'Content-Type': 'application/json',
  },
})
```

From src/lib/query.ts (staleTime will be 30min after Plan 02-01 runs):
```typescript
import { QueryClient } from '@tanstack/vue-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 30, // 30 minutes — static seeded data
    },
  },
})
```

TanStack Query v5 patterns:
- `useQuery` from `@tanstack/vue-query` — NOT from `@tanstack/query-core`
- No `onError`/`onSuccess` callbacks (removed in v5) — use returned `error` ref in templates or `watch(error, ...)`
- `MaybeRefOrGetter<string>` + `toValue()` for reactive params
- `retry` option accepts a function: `(failureCount, error) => boolean`
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useApplicants composable for applicant list query</name>
  <files>src/composables/useApplicants.ts</files>
  <action>
Create `src/composables/useApplicants.ts` wrapping TanStack Query's `useQuery` for GET /api/v1/applicants.

**Implementation details:**

```typescript
import { useQuery } from '@tanstack/vue-query'
import type { Applicant, ApiResponse } from '@/types/api'
import { http } from '@/lib/http'

export function useApplicants() {
  return useQuery<Applicant[]>({
    queryKey: ['applicants'],
    queryFn: async () => {
      const { data } = await http.get<ApiResponse<Applicant[]>>('/api/v1/applicants')
      return data.data
    },
  })
}
```

**Key decisions:**
- Query key: `['applicants']` — flat, simple, matches TanStack Query convention
- The `queryFn` unwraps Laravel's `{ data: T }` envelope via `data.data` (Axios response `.data` contains the API body, which itself has a `.data` property from `ApiResponse<T>`)
- Generic type parameter `<Applicant[]>` on `useQuery` so the returned `data` ref is typed as `Applicant[] | undefined`
- No custom error handling needed — the list endpoint does not return 422 domain errors; generic TanStack Query error handling is sufficient
- Import `http` from `@/lib/http` — NEVER import `axios` directly (project rule)
- No retry customization — default TanStack Query retry (3 attempts with exponential backoff) is fine for the list endpoint

**Do NOT:**
- Add `onError`/`onSuccess` callbacks (removed in TanStack Query v5)
- Import `axios` directly — use `http` from `@/lib/http`
- Add staleTime per-query — the global 30min default from QueryClient is correct
  </action>
  <verify>
    <automated>cd /Users/otisz/Projects/oktatasi-hivatal/client && npx vue-tsc --noEmit && npx biome check .</automated>
  </verify>
  <done>
- src/composables/useApplicants.ts exists and exports `useApplicants` function
- useQuery is called with queryKey ['applicants'] and queryFn fetching GET /api/v1/applicants
- Return type is typed as Applicant[] (via useQuery generic)
- http is imported from @/lib/http (not axios directly)
- ApiResponse<Applicant[]> unwraps Laravel envelope
- TypeScript compiles, Biome passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useApplicantScore composable with 422 domain error discrimination</name>
  <files>src/composables/useApplicantScore.ts</files>
  <action>
Create `src/composables/useApplicantScore.ts` wrapping TanStack Query's `useQuery` for GET /api/v1/applicants/{id}/score with explicit 422 error discrimination.

**ScoreError discriminated union type:**

Export a `ScoreError` type as a discriminated union that components can inspect:
```typescript
export type ScoreError =
  | { kind: 'domain'; message: string }   // 422 — show verbatim API message
  | { kind: 'generic' }                   // network/5xx — show generic Hungarian text
```

- `kind: 'domain'` — the API returned a 422 with a Hungarian error message in `{ error: "..." }`. The `message` field contains the verbatim API error string. Components display this as-is.
- `kind: 'generic'` — network failure, timeout, 5xx, or any non-422 error. Components show a generic Hungarian error message like "Hiba tortent. Probalja ujra."

**Composable implementation:**

```typescript
import { useQuery } from '@tanstack/vue-query'
import axios from 'axios'
import type { MaybeRefOrGetter } from 'vue'
import { computed, toValue } from 'vue'
import type { ApiError, ScoreResult } from '@/types/api'
import { http } from '@/lib/http'

export type ScoreError =
  | { kind: 'domain'; message: string }
  | { kind: 'generic' }

export function useApplicantScore(id: MaybeRefOrGetter<string>) {
  return useQuery<ScoreResult, ScoreError>({
    queryKey: computed(() => ['applicants', 'score', toValue(id)]),
    queryFn: async () => {
      try {
        const { data } = await http.get<ScoreResult>(
          `/api/v1/applicants/${toValue(id)}/score`,
        )
        return data
      } catch (e) {
        if (axios.isAxiosError(e) && e.response?.status === 422) {
          const body = e.response.data as ApiError
          throw { kind: 'domain', message: body.error } satisfies ScoreError
        }
        throw { kind: 'generic' } satisfies ScoreError
      }
    },
    retry: (_, error) => error.kind !== 'domain',
  })
}
```

**Key decisions:**
- **Accepts `MaybeRefOrGetter<string>`** for the applicant ID — this handles both reactive refs and plain strings. Use `toValue(id)` to unwrap inside queryFn and queryKey.
- **Query key is `computed()`** — wrapping in `computed()` ensures reactivity when `id` changes (e.g., navigating from one applicant to another). The flat array form `['applicants', 'score', toValue(id)]` inside computed is clean and reactive.
- **422 discrimination in queryFn** — Axios throws on non-2xx. The catch block checks `axios.isAxiosError(e) && e.response?.status === 422` to narrow to domain errors. The `e.response.data` is cast to `ApiError` to extract the verbatim Hungarian message.
- **`satisfies ScoreError`** — TypeScript 4.9+ operator ensures the thrown object matches the ScoreError union at compile time without widening the type.
- **Retry disabled for domain errors** — `retry: (_, error) => error.kind !== 'domain'` prevents retrying deterministic 422s while still retrying transient network/5xx failures (default 3 retries).
- **Score endpoint does NOT use ApiResponse<T> envelope** — the score endpoint returns `ScoreResult` directly (not wrapped in `{ data: ... }`), so `data` from Axios response is the ScoreResult itself. This differs from the applicants list endpoint which uses the Laravel Resource envelope.

**IMPORTANT:** The `axios` import on line 2 is for `axios.isAxiosError()` type guard ONLY — it is NOT used to make HTTP requests. All HTTP requests go through `http` from `@/lib/http`. This is the one exception where importing from `axios` directly is necessary (for the static type narrowing utility).

**Do NOT:**
- Use `onError`/`onSuccess` callbacks (removed in TanStack Query v5)
- Use `http` from `@/lib/http` for `isAxiosError` check — `axios.isAxiosError` is a static utility on the `axios` default export
- Destructure `route.params.id` to a plain variable before passing to this composable — it breaks reactivity. Callers must use `toRef(() => route.params.id as string)`.
  </action>
  <verify>
    <automated>cd /Users/otisz/Projects/oktatasi-hivatal/client && npx vue-tsc --noEmit && npx biome check .</automated>
  </verify>
  <done>
- src/composables/useApplicantScore.ts exists and exports `useApplicantScore` function and `ScoreError` type
- useQuery is called with computed queryKey including reactive id
- queryFn catches AxiosError, checks status 422, throws typed ScoreError
- Domain error (kind: 'domain') carries verbatim message from ApiError.error
- Generic error (kind: 'generic') thrown for all non-422 failures
- retry function skips domain errors, allows retries for generic errors
- id parameter accepts MaybeRefOrGetter<string> for reactivity safety
- http is imported from @/lib/http for API calls
- axios imported ONLY for isAxiosError type guard
- TypeScript compiles, Biome passes
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Type check passes:** `npx vue-tsc --noEmit` exits 0
2. **Lint passes:** `npx biome check .` exits 0
3. **useApplicants exists:** `src/composables/useApplicants.ts` exports `useApplicants` function
4. **useApplicantScore exists:** `src/composables/useApplicantScore.ts` exports `useApplicantScore` function and `ScoreError` type
5. **Correct imports:** Both composables import `http` from `@/lib/http` (not axios directly for HTTP calls)
6. **422 discrimination:** `useApplicantScore` catches AxiosError, checks `.response?.status === 422`, throws `{ kind: 'domain', message }` vs `{ kind: 'generic' }`
7. **Retry guard:** `retry` function returns `false` for domain errors, `true` for generic
8. **Reactive query key:** `useApplicantScore` uses `computed(() => [...])` for its queryKey
</verification>

<success_criteria>
- useApplicants() returns typed Applicant[] via TanStack Query wrapping GET /api/v1/applicants
- useApplicantScore(id) returns typed ScoreResult via TanStack Query wrapping GET /api/v1/applicants/{id}/score
- 422 responses produce ScoreError { kind: 'domain', message: string } with verbatim API message
- Non-422 errors produce ScoreError { kind: 'generic' }
- Domain errors (422) are not retried; generic errors use default retry behavior
- All TypeScript compiles, Biome passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-routing-and-data-layer/02-02-SUMMARY.md`
</output>
