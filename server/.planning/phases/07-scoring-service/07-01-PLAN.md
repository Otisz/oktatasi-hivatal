---
phase: 07-scoring-service
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/Services/AdmissionScoringService.php
  - tests/Unit/Services/AdmissionScoringServiceTest.php
autonomous: true
requirements: [BIZ-05, VAL-01, VAL-02, VAL-03, VAL-04, VAL-05, TEST-08]

must_haves:
  truths:
    - "VO mapping occurs first — FailedExamException is thrown before any explicit validation step"
    - "MissingGlobalMandatorySubjectException thrown when magyar/tortenelem/matematika are absent"
    - "MissingProgramMandatorySubjectException thrown when programme mandatory subject is missing"
    - "ProgramMandatorySubjectLevelException thrown when mandatory subject is at wrong level"
    - "MissingElectiveSubjectException thrown when no elective subject matches"
    - "calculateForApplicant() returns Score VO with correct basePoints and bonusPoints on happy path"
    - "Validation chain order is enforced: step 1 (VO mapping) -> step 2 (global mandatory) -> step 3 (programme mandatory) -> step 4 (level check) -> step 5 (elective check)"
  artifacts:
    - path: "app/Services/AdmissionScoringService.php"
      provides: "Orchestrating scoring service"
      contains: "final class AdmissionScoringService"
    - path: "tests/Unit/Services/AdmissionScoringServiceTest.php"
      provides: "Unit tests for all exception paths and happy path"
      min_lines: 80
  key_links:
    - from: "app/Services/AdmissionScoringService.php"
      to: "app/Services/ProgramRegistry.php"
      via: "Constructor injection and findByApplicant() call"
      pattern: "->findByApplicant\\("
    - from: "app/Services/AdmissionScoringService.php"
      to: "app/Services/BasePointCalculator.php"
      via: "Constructor injection and calculate() call"
      pattern: "basePointCalculator->calculate\\("
    - from: "app/Services/AdmissionScoringService.php"
      to: "app/Services/BonusPointCalculator.php"
      via: "Constructor injection and calculate() call"
      pattern: "bonusPointCalculator->calculate\\("
    - from: "app/Services/AdmissionScoringService.php"
      to: "app/ValueObjects/ExamResult.php"
      via: "VO construction from ApplicantExamResult rows"
      pattern: "new ExamResult\\("
    - from: "app/Services/AdmissionScoringService.php"
      to: "app/ValueObjects/LanguageCertificate.php"
      via: "VO construction from ApplicantBonusPoint rows"
      pattern: "new LanguageCertificate\\("
---

<objective>
Implement AdmissionScoringService as the orchestrator that maps Eloquent rows to VOs, runs the five-step ordered validation chain, and delegates to calculators to produce a Score VO.

Purpose: This is the central service connecting all previously built components. It accepts an Applicant model (with eager-loaded relationships), maps DB rows to typed VOs (which triggers step 1 validation automatically), runs steps 2-5 as explicit checks, then delegates to BasePointCalculator and BonusPointCalculator for the final Score.

Output: One final service class in app/Services/ and one Pest unit test file in tests/Unit/Services/ covering all 5 exception paths plus the happy path.
</objective>

<execution_context>
@/Users/otisz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/otisz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-scoring-service/07-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From app/Services/ProgramRegistry.php:
```php
final class ProgramRegistry
{
    public function findByApplicant(Applicant $applicant): ProgramRequirementsInterface
    {
        return new DatabaseProgramRequirements($applicant->program);
    }
}
```

From app/Contracts/ProgramRequirementsInterface.php:
```php
interface ProgramRequirementsInterface
{
    public function getMandatorySubject(): SubjectName;
    /** @return array<int, SubjectName> */
    public function getElectiveSubjects(): array;
    public function getMandatorySubjectLevel(): ?ExamLevel;
}
```

From app/Services/BasePointCalculator.php:
```php
final class BasePointCalculator
{
    public function calculate(ExamResult $mandatory, ExamResult $bestElective): int
    {
        return min(($mandatory->points() + $bestElective->points()) * 2, 400);
    }
}
```

From app/Services/BonusPointCalculator.php:
```php
final class BonusPointCalculator
{
    /**
     * @param array<int, ExamResult> $examResults
     * @param array<int, LanguageCertificate> $certificates
     */
    public function calculate(array $examResults, array $certificates): int
}
```

From app/ValueObjects/ExamResult.php:
```php
final readonly class ExamResult
{
    public function __construct(
        public SubjectName $subject,
        public ExamLevel $level,
        public int $percentage,
    ) {
        throw_if($percentage < 0 || $percentage > 100, \InvalidArgumentException::class, ...);
        throw_if($percentage < 20, FailedExamException::class, $subject, $percentage);
    }
    public function points(): int { return $this->percentage; }
    public function isAdvancedLevel(): bool { return ExamLevel::Advanced === $this->level; }
}
```

From app/ValueObjects/LanguageCertificate.php:
```php
final readonly class LanguageCertificate
{
    public function __construct(
        public LanguageCertificateType $type,
        public string $language,
    ) {}
    public function points(): int { return $this->type->points(); }
    public function language(): string { return $this->language; }
}
```

From app/ValueObjects/Score.php:
```php
final readonly class Score
{
    public function __construct(
        public int $basePoints,
        public int $bonusPoints,
    ) { /* validates non-negative */ }
    public function total(): int { return $this->basePoints + $this->bonusPoints; }
}
```

From app/Models/Applicant.php:
```php
final class Applicant extends Model
{
    public function program(): BelongsTo { return $this->belongsTo(Program::class); }
    public function examResults(): HasMany { return $this->hasMany(ApplicantExamResult::class); }
    public function bonusPoints(): HasMany { return $this->hasMany(ApplicantBonusPoint::class); }
}
```

From app/Models/ApplicantExamResult.php (casts):
```php
// subject_name => SubjectName::class, level => ExamLevel::class
// percentage is plain int (no cast)
```

From app/Models/ApplicantBonusPoint.php (casts):
```php
// type => LanguageCertificateType::class
// language is plain string (no cast), category is plain string (no cast)
```

From app/Enums/SubjectName.php:
```php
public static function globallyMandatory(): array
{
    return [self::HungarianLanguageAndLiterature, self::History, self::Mathematics];
}
```

Exception constructors:
```php
// FailedExamException::__construct(SubjectName $subject, int $percentage)
//   — auto-thrown by ExamResult constructor when percentage < 20
// MissingGlobalMandatorySubjectException::__construct()
//   — no args, hardcoded Hungarian message
// MissingProgramMandatorySubjectException::__construct(SubjectName $subject)
//   — takes the missing subject
// ProgramMandatorySubjectLevelException::__construct(SubjectName $subject, ExamLevel $requiredLevel)
//   — takes subject and expected level
// MissingElectiveSubjectException::__construct()
//   — no args, hardcoded Hungarian message
```

Model stub pattern (from tests/Unit/Services/DatabaseProgramRequirementsTest.php):
```php
// Use new Model + setAttribute() for enum-cast attributes
// Use setRelation() to attach HasMany collections
$subject = new ProgramSubject;
$subject->setAttribute('subject_name', SubjectName::Mathematics);
$subject->setAttribute('requirement_type', RequirementType::Mandatory);
```

Mockery usage (from research, confirmed installed ^1.6):
```php
use Mockery;
$registry = Mockery::mock(ProgramRegistry::class);
$registry->shouldReceive('findByApplicant')->once()->andReturn($requirements);
// Pest auto-calls Mockery::close() after each test
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: TDD AdmissionScoringService — Tests First</name>
  <files>tests/Unit/Services/AdmissionScoringServiceTest.php</files>
  <behavior>
    - Test 1 (VAL-01 / step 1 priority): throws FailedExamException when any exam has percentage below 20 — this happens DURING VO mapping, before any explicit validation
    - Test 2 (VAL-02 / step 2): throws MissingGlobalMandatorySubjectException when magyar nyelv es irodalom is absent from exam results — all exams pass >= 20% but a globally mandatory subject is missing
    - Test 3 (VAL-02 / step 2): throws MissingGlobalMandatorySubjectException when tortenelem is absent
    - Test 4 (VAL-02 / step 2): throws MissingGlobalMandatorySubjectException when matematika is absent
    - Test 5 (VAL-03 / step 3): throws MissingProgramMandatorySubjectException when the programme's mandatory subject is missing from exam results
    - Test 6 (VAL-04 / step 4): throws ProgramMandatorySubjectLevelException when mandatory subject is present but at wrong level (kozep when emelt required)
    - Test 7 (VAL-05 / step 5): throws MissingElectiveSubjectException when no exam result matches any programme elective subject
    - Test 8 (BIZ-05 / happy path): returns Score VO with correct basePoints and bonusPoints when all validation passes — mocked calculators return predetermined values
    - Test 9 (ordering): confirms step 1 fires before step 2 — applicant has BOTH a failing exam (<20%) AND missing global mandatory; FailedExamException must win
  </behavior>
  <action>
    Create `tests/Unit/Services/AdmissionScoringServiceTest.php` using `php artisan make:test --pest --unit Services/AdmissionScoringServiceTest --no-interaction`.

    Write 9 test cases. Build all tests using real Applicant model stubs (not DB), Mockery mocks for the three dependencies (ProgramRegistry, BasePointCalculator, BonusPointCalculator), and Mockery mock for ProgramRequirementsInterface.

    **Helper functions at the top of the test file** (following the DatabaseProgramRequirementsTest pattern):

    ```php
    function makeExamResultRow(SubjectName $subject, ExamLevel $level, int $percentage): ApplicantExamResult
    {
        $row = new ApplicantExamResult;
        $row->setAttribute('subject_name', $subject);
        $row->setAttribute('level', $level);
        $row->setAttribute('percentage', $percentage);
        return $row;
    }

    function makeBonusPointRow(LanguageCertificateType $type, string $language): ApplicantBonusPoint
    {
        $row = new ApplicantBonusPoint;
        $row->setAttribute('type', $type);
        $row->setAttribute('language', $language);
        return $row;
    }

    function makeApplicantWithExams(array $examRows, array $bonusRows = []): Applicant
    {
        $applicant = new Applicant;
        $applicant->setRelation('examResults', \Illuminate\Database\Eloquent\Collection::make($examRows));
        $applicant->setRelation('bonusPoints', \Illuminate\Database\Eloquent\Collection::make($bonusRows));
        return $applicant;
    }
    ```

    **Mock setup pattern** (reused across tests):

    For exception path tests (steps 2-5), mock ProgramRegistry to return a Mockery mock of ProgramRequirementsInterface. Configure the interface mock with the appropriate getMandatorySubject(), getElectiveSubjects(), getMandatorySubjectLevel() return values. BasePointCalculator and BonusPointCalculator should use `Mockery::mock()` with no expectations (they should NOT be called on exception paths).

    For the happy path test (Test 8), configure all three mocks: registry returns requirements, baseCalc->calculate returns a specific int (e.g. 370), bonusCalc->calculate returns a specific int (e.g. 100). Assert the returned Score VO has the expected basePoints and bonusPoints.

    For step 1 tests (Tests 1, 9), ProgramRegistry should use `shouldNotReceive('findByApplicant')` since VO mapping throws before the registry is ever called.

    **Test scenarios:**

    Test 1 — FailedExamException (step 1):
    - Exam: magyar 15% (below 20)
    - No need for ProgramRegistry/calculator mocks to be called
    - `expect(fn () => $service->calculateForApplicant($applicant))->toThrow(FailedExamException::class)`

    Test 2 — MissingGlobalMandatory (step 2, missing magyar):
    - Exams: tortenelem 50%, matematika 60%, informatika 80% — no magyar
    - Registry mock not needed for step 2 (global mandatory check is before registry call)
    - `->toThrow(MissingGlobalMandatorySubjectException::class)`

    Test 3 — MissingGlobalMandatory (step 2, missing tortenelem):
    - Exams: magyar 50%, matematika 60%, informatika 80% — no tortenelem
    - `->toThrow(MissingGlobalMandatorySubjectException::class)`

    Test 4 — MissingGlobalMandatory (step 2, missing matematika):
    - Exams: magyar 50%, tortenelem 60%, informatika 80% — no matematika
    - `->toThrow(MissingGlobalMandatorySubjectException::class)`

    Test 5 — MissingProgramMandatory (step 3):
    - Exams: magyar 50%, tortenelem 60%, matematika 70% — all 3 globals present, but programme mandatory (e.g. EnglishLanguage) is missing
    - Requirements mock: getMandatorySubject() returns SubjectName::EnglishLanguage
    - `->toThrow(MissingProgramMandatorySubjectException::class)`

    Test 6 — ProgramMandatorySubjectLevel (step 4):
    - Exams: magyar 50%, tortenelem 60%, matematika 70%, angol 80% (kozep level)
    - Requirements mock: getMandatorySubject() returns SubjectName::EnglishLanguage, getMandatorySubjectLevel() returns ExamLevel::Advanced
    - Angol is present but at Intermediate, not Advanced
    - `->toThrow(ProgramMandatorySubjectLevelException::class)`

    Test 7 — MissingElective (step 5):
    - Exams: magyar 50%, tortenelem 60%, matematika 70%, angol 80% (emelt)
    - Requirements mock: getMandatorySubject() returns EnglishLanguage, getMandatorySubjectLevel() returns ExamLevel::Advanced, getElectiveSubjects() returns [SubjectName::FrenchLanguage, SubjectName::GermanLanguage]
    - None of the applicant's non-mandatory exams match the electives
    - `->toThrow(MissingElectiveSubjectException::class)`

    Test 8 — Happy path:
    - Exams: magyar 50%, tortenelem 60%, matematika 90% (emelt), informatika 95%
    - Bonus: B2 angol
    - Requirements mock: getMandatorySubject() returns Mathematics, getMandatorySubjectLevel() returns null, getElectiveSubjects() returns [Informatics, Physics, Biology, Chemistry]
    - BasePointCalculator mock: ->shouldReceive('calculate')->once()->andReturn(370)
    - BonusPointCalculator mock: ->shouldReceive('calculate')->once()->andReturn(100)
    - Assert: $score->basePoints === 370, $score->bonusPoints === 100, $score->total() === 470

    Test 9 — Step 1 fires before step 2:
    - Exams: magyar 15% (below 20 — triggers step 1), NO tortenelem (would trigger step 2)
    - FailedExamException must be thrown, NOT MissingGlobalMandatorySubjectException
    - Registry uses `shouldNotReceive('findByApplicant')` — proves step 2+ never reached

    Run tests after writing them — they MUST fail because AdmissionScoringService does not exist yet.

    Run `vendor/bin/pint --dirty --format agent` after creating the test file.
  </action>
  <verify>
    <automated>cd /Users/otisz/Projects/oktatasi-hivatal/server && php artisan test --compact --filter=AdmissionScoringServiceTest 2>&1 | tail -5</automated>
  </verify>
  <done>AdmissionScoringServiceTest.php exists with 9 test cases. All tests fail because AdmissionScoringService class does not exist. Pint clean.</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: GREEN — Implement AdmissionScoringService</name>
  <files>app/Services/AdmissionScoringService.php</files>
  <behavior>
    - AdmissionScoringService is a `final class` (NOT `final readonly class`) with constructor-injected ProgramRegistry, BasePointCalculator, BonusPointCalculator
    - Single public method: `calculateForApplicant(Applicant $applicant): Score`
    - Step 1 (implicit): Map ApplicantExamResult rows to ExamResult VOs — ExamResult constructor auto-throws FailedExamException for percentage < 20
    - Step 1b: Map ApplicantBonusPoint rows to LanguageCertificate VOs
    - Step 2: Check all three globally mandatory subjects are present in mapped exam results
    - After step 2: Resolve programme requirements via ProgramRegistry::findByApplicant()
    - Step 3: Find programme mandatory subject in mapped exam results — throw MissingProgramMandatorySubjectException if absent
    - Step 4: If programme requires specific level, check mandatory exam matches — throw ProgramMandatorySubjectLevelException if wrong level
    - Step 5: Find best elective exam from programme elective subjects — throw MissingElectiveSubjectException if none found
    - Calculate: Delegate to BasePointCalculator(mandatoryResult, bestElective) and BonusPointCalculator(allExamResults, allCertificates)
    - Return: new Score(basePoints, bonusPoints)
  </behavior>
  <action>
    Create `app/Services/AdmissionScoringService.php` using `php artisan make:class Services/AdmissionScoringService --no-interaction`.

    Replace the generated file content with the full implementation:

    ```php
    <?php

    declare(strict_types=1);

    namespace App\Services;

    use App\Contracts\ProgramRequirementsInterface;
    use App\Enums\SubjectName;
    use App\Exceptions\MissingElectiveSubjectException;
    use App\Exceptions\MissingGlobalMandatorySubjectException;
    use App\Exceptions\MissingProgramMandatorySubjectException;
    use App\Exceptions\ProgramMandatorySubjectLevelException;
    use App\Models\Applicant;
    use App\Models\ApplicantBonusPoint;
    use App\Models\ApplicantExamResult;
    use App\ValueObjects\ExamResult;
    use App\ValueObjects\LanguageCertificate;
    use App\ValueObjects\Score;

    final class AdmissionScoringService
    {
        public function __construct(
            private ProgramRegistry $programRegistry,
            private BasePointCalculator $basePointCalculator,
            private BonusPointCalculator $bonusPointCalculator,
        ) {}

        public function calculateForApplicant(Applicant $applicant): Score
        {
            // Step 1: Map Eloquent rows to VOs — ExamResult constructor throws FailedExamException if < 20%
            /** @var array<int, ExamResult> $examResults */
            $examResults = $applicant->examResults
                ->map(fn (ApplicantExamResult $row): ExamResult => new ExamResult(
                    $row->subject_name,
                    $row->level,
                    $row->percentage,
                ))
                ->values()
                ->all();

            /** @var array<int, LanguageCertificate> $certificates */
            $certificates = $applicant->bonusPoints
                ->map(fn (ApplicantBonusPoint $row): LanguageCertificate => new LanguageCertificate(
                    $row->type,
                    $row->language,
                ))
                ->values()
                ->all();

            // Step 2: Global mandatory check
            $this->validateGlobalMandatorySubjects($examResults);

            // Resolve programme requirements (after step 1+2 to preserve exception priority)
            $requirements = $this->programRegistry->findByApplicant($applicant);

            // Step 3: Programme mandatory subject present
            $mandatoryResult = $this->validateProgramMandatorySubject($examResults, $requirements);

            // Step 4: Programme mandatory subject level
            $this->validateMandatoryLevel($mandatoryResult, $requirements);

            // Step 5: Elective subject present — returns the best-scoring elective
            $bestElective = $this->findBestElective($examResults, $requirements);

            // Calculate score
            $basePoints = $this->basePointCalculator->calculate($mandatoryResult, $bestElective);
            $bonusPoints = $this->bonusPointCalculator->calculate($examResults, $certificates);

            return new Score($basePoints, $bonusPoints);
        }

        /**
         * @param array<int, ExamResult> $examResults
         */
        private function validateGlobalMandatorySubjects(array $examResults): void
        {
            $subjectNames = array_map(
                fn (ExamResult $r): SubjectName => $r->subject,
                $examResults,
            );

            foreach (SubjectName::globallyMandatory() as $required) {
                if (! in_array($required, $subjectNames, true)) {
                    throw new MissingGlobalMandatorySubjectException;
                }
            }
        }

        /**
         * @param array<int, ExamResult> $examResults
         */
        private function validateProgramMandatorySubject(
            array $examResults,
            ProgramRequirementsInterface $requirements,
        ): ExamResult {
            $mandatorySubject = $requirements->getMandatorySubject();

            foreach ($examResults as $result) {
                if ($result->subject === $mandatorySubject) {
                    return $result;
                }
            }

            throw new MissingProgramMandatorySubjectException($mandatorySubject);
        }

        private function validateMandatoryLevel(
            ExamResult $mandatory,
            ProgramRequirementsInterface $requirements,
        ): void {
            $requiredLevel = $requirements->getMandatorySubjectLevel();

            if ($requiredLevel !== null && ! $mandatory->isAdvancedLevel()) {
                throw new ProgramMandatorySubjectLevelException($mandatory->subject, $requiredLevel);
            }
        }

        /**
         * Find the best-scoring elective exam result. First-encountered wins on ties (strict > comparison).
         *
         * @param array<int, ExamResult> $examResults
         */
        private function findBestElective(
            array $examResults,
            ProgramRequirementsInterface $requirements,
        ): ExamResult {
            $electiveSubjects = $requirements->getElectiveSubjects();
            $best = null;

            foreach ($examResults as $result) {
                if (in_array($result->subject, $electiveSubjects, true)) {
                    if ($best === null || $result->points() > $best->points()) {
                        $best = $result;
                    }
                }
            }

            if ($best === null) {
                throw new MissingElectiveSubjectException;
            }

            return $best;
        }
    }
    ```

    IMPORTANT IMPLEMENTATION NOTES:
    - Use `final class` NOT `final readonly class` — keeps service mockable and consistent with sibling services
    - Constructor uses `private` (not `private readonly`) for the three dependencies — `final class` bodies do not require explicit `readonly` on properties
    - VO mapping (step 1) happens BEFORE ProgramRegistry::findByApplicant() — this guarantees FailedExamException fires before UnknownProgramException
    - Global mandatory check (step 2) also happens BEFORE ProgramRegistry call — step 2 only needs the mapped ExamResult array, not programme requirements
    - Use strict `in_array($enum, $array, true)` for all enum membership checks — project decision from STATE.md [05-01]
    - Use `foreach` with strict `===` for finding mandatory exam — project decision from STATE.md [05-01]
    - Best elective uses strict `>` (not `>=`) — first-encountered wins on ties per research recommendation

    Run all tests — all 9 must pass.

    Run `vendor/bin/pint --dirty --format agent` after creating the service file.
  </action>
  <verify>
    <automated>cd /Users/otisz/Projects/oktatasi-hivatal/server && php artisan test --compact --filter=AdmissionScoringServiceTest</automated>
  </verify>
  <done>AdmissionScoringService implemented. All 9 tests pass: step 1 FailedExamException, step 2 MissingGlobalMandatory (3 subjects), step 3 MissingProgramMandatory, step 4 ProgramMandatorySubjectLevel, step 5 MissingElective, happy path Score VO, ordering guarantee. Pint clean.</done>
</task>

</tasks>

<verification>
Run all unit tests to confirm no regressions:
```bash
cd /Users/otisz/Projects/oktatasi-hivatal/server && php artisan test --compact tests/Unit/
```

Run Pint on all modified files:
```bash
cd /Users/otisz/Projects/oktatasi-hivatal/server && vendor/bin/pint --dirty --format agent
```

Verify the service file exists and is a final class:
```bash
grep -n "final class" app/Services/AdmissionScoringService.php
```

Verify test file covers all exception paths:
```bash
grep -c "^it(" tests/Unit/Services/AdmissionScoringServiceTest.php
```
Expected: 9
</verification>

<success_criteria>
- AdmissionScoringService::calculateForApplicant(Applicant) maps VOs first (step 1), then validates in order (steps 2-5), then delegates to calculators
- FailedExamException fires before MissingGlobalMandatorySubjectException when both conditions exist
- MissingGlobalMandatorySubjectException thrown for each missing global mandatory subject
- MissingProgramMandatorySubjectException thrown when programme mandatory is absent
- ProgramMandatorySubjectLevelException thrown when mandatory level does not match
- MissingElectiveSubjectException thrown when no elective subject matches
- Happy path returns Score VO with basePoints from BasePointCalculator and bonusPoints from BonusPointCalculator
- All 9 unit tests in AdmissionScoringServiceTest pass
- No regressions in existing test suite
- Pint formatting clean on all modified files
</success_criteria>

<output>
After completion, create `.planning/phases/07-scoring-service/07-01-SUMMARY.md`
</output>
