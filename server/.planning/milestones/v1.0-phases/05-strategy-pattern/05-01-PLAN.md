---
phase: 05-strategy-pattern
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/Contracts/ProgramRequirementsInterface.php
  - app/Services/DatabaseProgramRequirements.php
  - app/Services/ProgramRegistry.php
  - tests/Unit/Services/DatabaseProgramRequirementsTest.php
  - tests/Unit/Services/ProgramRegistryTest.php
autonomous: true
requirements:
  - DOM-08
  - BIZ-01
  - BIZ-02
  - TEST-04
  - TEST-05

must_haves:
  truths:
    - "DatabaseProgramRequirements::getMandatorySubject() returns SubjectName::Mathematics for a Program with matematika as mandatory subject"
    - "DatabaseProgramRequirements::getElectiveSubjects() returns [SubjectName::Physics, SubjectName::Biology] for a Program with those elective subjects"
    - "DatabaseProgramRequirements::getMandatorySubjectLevel() returns ExamLevel::Advanced when the mandatory subject has required_level set, and null when it does not"
    - "DatabaseProgramRequirements::getMandatorySubject() throws UnknownProgramException when no mandatory subject exists on the Program"
    - "ProgramRegistry::findByApplicant() returns a DatabaseProgramRequirements instance that implements ProgramRequirementsInterface"
    - "All unit tests pass without any database access — tests use real model instances with setRelation/setAttribute only"
  artifacts:
    - path: "app/Contracts/ProgramRequirementsInterface.php"
      provides: "Interface contract with getMandatorySubject(), getElectiveSubjects(), getMandatorySubjectLevel()"
      contains: "interface ProgramRequirementsInterface"
    - path: "app/Services/DatabaseProgramRequirements.php"
      provides: "Concrete implementation filtering Program->subjects by RequirementType"
      contains: "final readonly class DatabaseProgramRequirements implements ProgramRequirementsInterface"
    - path: "app/Services/ProgramRegistry.php"
      provides: "Service resolving ProgramRequirementsInterface from Applicant's program relationship"
      contains: "final class ProgramRegistry"
    - path: "tests/Unit/Services/DatabaseProgramRequirementsTest.php"
      provides: "Unit tests for mandatory subject, elective subjects, mandatory level, and unknown program edge case"
      contains: "DatabaseProgramRequirements"
    - path: "tests/Unit/Services/ProgramRegistryTest.php"
      provides: "Unit test for findByApplicant returning correct type"
      contains: "ProgramRegistry"
  key_links:
    - from: "app/Services/DatabaseProgramRequirements.php"
      to: "app/Contracts/ProgramRequirementsInterface.php"
      via: "implements ProgramRequirementsInterface"
      pattern: "implements ProgramRequirementsInterface"
    - from: "app/Services/DatabaseProgramRequirements.php"
      to: "app/Models/Program.php"
      via: "constructor accepts Program, filters subjects collection by RequirementType"
      pattern: "this->program->subjects"
    - from: "app/Services/ProgramRegistry.php"
      to: "app/Services/DatabaseProgramRequirements.php"
      via: "findByApplicant creates DatabaseProgramRequirements from applicant's program"
      pattern: "new DatabaseProgramRequirements"
    - from: "app/Services/DatabaseProgramRequirements.php"
      to: "app/Exceptions/UnknownProgramException.php"
      via: "throws when no mandatory subject found on program"
      pattern: "throw new UnknownProgramException"
---

<objective>
Create the Strategy pattern layer: ProgramRequirementsInterface contract, DatabaseProgramRequirements implementation that filters Program model's subjects by RequirementType, ProgramRegistry that resolves requirements from an Applicant, and unit tests for both service classes using real model instances with setRelation/setAttribute (no database access).

Purpose: This layer sits between Eloquent models and the Phase 7 scoring service. It abstracts programme-specific subject requirements (mandatory subject, elective subjects, required exam level) behind an interface so the scoring engine depends on a contract, not raw model queries.
Output: 3 production files (interface + 2 services) and 2 unit test files.
</objective>

<execution_context>
@/Users/otisz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/otisz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-strategy-pattern/05-RESEARCH.md
</context>

<interfaces>
<!-- Models, enums, and exceptions the new services interact with. Extracted from codebase. -->

From app/Models/Program.php:
```php
final class Program extends Model
{
    use HasFactory, HasUuids;
    // No $fillable — Model::unguard() active in AppServiceProvider
    public function subjects(): HasMany  // -> ProgramSubject
    public function applicants(): HasMany  // -> Applicant
}
```

From app/Models/ProgramSubject.php:
```php
final class ProgramSubject extends Model
{
    use HasFactory, HasUuids;
    // casts: subject_name => SubjectName, requirement_type => RequirementType, required_level => ExamLevel
    public function program(): BelongsTo  // -> Program
}
```

From app/Models/Applicant.php:
```php
final class Applicant extends Model
{
    use HasFactory, HasUuids;
    public function program(): BelongsTo  // -> Program
    public function examResults(): HasMany  // -> ApplicantExamResult
    public function bonusPoints(): HasMany  // -> ApplicantBonusPoint
}
```

From app/Enums/SubjectName.php:
```php
enum SubjectName: string
{
    case HungarianLanguageAndLiterature = 'magyar nyelv és irodalom';
    case History = 'történelem';
    case Mathematics = 'matematika';
    case EnglishLanguage = 'angol nyelv';
    // ... 9 more cases
}
```

From app/Enums/ExamLevel.php:
```php
enum ExamLevel: string { case Intermediate = 'közép'; case Advanced = 'emelt'; }
```

From app/Enums/RequirementType.php:
```php
enum RequirementType: string { case Mandatory = 'mandatory'; case Elective = 'elective'; }
```

From app/Exceptions/UnknownProgramException.php:
```php
final class UnknownProgramException extends AdmissionException
{
    public function __construct()
    {
        parent::__construct('nem lehetséges a pontszámítás ismeretlen szak miatt');
    }
}
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create ProgramRequirementsInterface, DatabaseProgramRequirements, and ProgramRegistry</name>
  <files>app/Contracts/ProgramRequirementsInterface.php, app/Services/DatabaseProgramRequirements.php, app/Services/ProgramRegistry.php</files>
  <action>
Create the three production files. Use `php artisan make:class` to scaffold, then replace content.

```bash
php artisan make:class Contracts/ProgramRequirementsInterface --no-interaction
php artisan make:class Services/DatabaseProgramRequirements --no-interaction
php artisan make:class Services/ProgramRegistry --no-interaction
```

**1. ProgramRequirementsInterface** (`app/Contracts/ProgramRequirementsInterface.php`):

Replace the scaffolded class with a PHP interface. Must have `declare(strict_types=1)`, namespace `App\Contracts`, and these three method signatures:
- `getMandatorySubject(): SubjectName` — returns the single mandatory subject for the programme
- `getElectiveSubjects(): array` — returns elective subjects; add PHPDoc `@return array<int, SubjectName>`
- `getMandatorySubjectLevel(): ?ExamLevel` — returns the required exam level for the mandatory subject, or null if any level accepted

Import `App\Enums\ExamLevel` and `App\Enums\SubjectName`. No implementation, just method signatures. The file defines an `interface`, NOT a `class`.

**2. DatabaseProgramRequirements** (`app/Services/DatabaseProgramRequirements.php`):

Replace scaffolded content. Must be `final readonly class` implementing `ProgramRequirementsInterface`. Namespace `App\Services`.

Constructor: `public function __construct(private Program $program) {}` — uses PHP 8 constructor property promotion.

`getMandatorySubject()`: Filter `$this->program->subjects` using `->firstWhere('requirement_type', RequirementType::Mandatory)`. If the result is `null`, throw `new UnknownProgramException()`. Otherwise return `$mandatory->subject_name`.

IMPORTANT — Collection::firstWhere() enum comparison: When attributes are set via `setAttribute()` and the model has enum casts, Eloquent returns the enum instance on read. `Collection::firstWhere()` uses loose equality which works with enum instances. If this fails during testing (returns null when it should match), use closure-based filtering instead:
```php
$mandatory = $this->program->subjects->first(
    fn (ProgramSubject $subject): bool => $subject->requirement_type === RequirementType::Mandatory
);
```
Start with the `firstWhere` approach. Only switch to closure if tests fail on enum comparison.

`getElectiveSubjects()`: Filter `$this->program->subjects->where('requirement_type', RequirementType::Elective)`, then `->values()->map(fn (ProgramSubject $subject): SubjectName => $subject->subject_name)->all()`. Add PHPDoc `@return array<int, SubjectName>`.

Same enum comparison note applies — use `->filter(fn (ProgramSubject $subject): bool => ...)` if `->where()` fails.

`getMandatorySubjectLevel()`: Use `->firstWhere('requirement_type', RequirementType::Mandatory)?->required_level`. Null-safe operator handles the case where no mandatory subject exists (returns null). This is separate from `getMandatorySubject()` — no exception thrown here, just nullable return.

Imports needed: `App\Contracts\ProgramRequirementsInterface`, `App\Enums\ExamLevel`, `App\Enums\RequirementType`, `App\Enums\SubjectName`, `App\Exceptions\UnknownProgramException`, `App\Models\Program`, `App\Models\ProgramSubject`.

**3. ProgramRegistry** (`app/Services/ProgramRegistry.php`):

Replace scaffolded content. Must be `final class` (NOT readonly — no constructor properties). Namespace `App\Services`.

Single method: `findByApplicant(Applicant $applicant): ProgramRequirementsInterface`. Body: `return new DatabaseProgramRequirements($applicant->program);`.

NOTE: This accesses `$applicant->program` which requires the program relationship to be eager-loaded in production (Phase 8 will handle this). In unit tests, `setRelation('program', $program)` bypasses lazy loading.

Imports needed: `App\Contracts\ProgramRequirementsInterface`, `App\Models\Applicant`.

After creating all three files, run:
```bash
vendor/bin/pint --dirty --format agent
```
  </action>
  <verify>
    <automated>vendor/bin/pint --dirty --format agent && php -l app/Contracts/ProgramRequirementsInterface.php && php -l app/Services/DatabaseProgramRequirements.php && php -l app/Services/ProgramRegistry.php</automated>
  </verify>
  <done>ProgramRequirementsInterface defines three method signatures with correct return types and PHPDoc. DatabaseProgramRequirements is final readonly, filters Program->subjects by RequirementType, throws UnknownProgramException when no mandatory subject found. ProgramRegistry delegates to DatabaseProgramRequirements via findByApplicant(). All three files pass Pint and PHP syntax check.</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for DatabaseProgramRequirements and ProgramRegistry</name>
  <files>tests/Unit/Services/DatabaseProgramRequirementsTest.php, tests/Unit/Services/ProgramRegistryTest.php</files>
  <action>
Scaffold both test files via artisan:
```bash
php artisan make:test --pest --unit --no-interaction Services/DatabaseProgramRequirementsTest
php artisan make:test --pest --unit --no-interaction Services/ProgramRegistryTest
```

CRITICAL: Activate the `pest-testing` skill before writing tests.

CRITICAL: These are unit tests in `tests/Unit/` — they do NOT boot the Laravel application. `Model::unguard()`, `preventLazyLoading()`, and `preventAccessingMissingAttributes()` are NOT active. Use `$model->setAttribute()` and `$model->setRelation()` exclusively. Do NOT use `fill()`, `create()`, or `factory()->make()`.

**DatabaseProgramRequirementsTest** (`tests/Unit/Services/DatabaseProgramRequirementsTest.php`):

Replace scaffolded content. Add `declare(strict_types=1)` at the top. Import: `App\Enums\ExamLevel`, `App\Enums\RequirementType`, `App\Enums\SubjectName`, `App\Exceptions\UnknownProgramException`, `App\Models\Program`, `App\Models\ProgramSubject`, `App\Services\DatabaseProgramRequirements`, `Illuminate\Database\Eloquent\Collection`.

Define three helper functions at the top of the file (before test cases):

```php
function makeProgramSubject(SubjectName $name, RequirementType $type, ?ExamLevel $level = null): ProgramSubject
{
    $subject = new ProgramSubject();
    $subject->setAttribute('subject_name', $name);
    $subject->setAttribute('requirement_type', $type);
    $subject->setAttribute('required_level', $level);
    return $subject;
}

function makeMandatorySubject(SubjectName $name, ?ExamLevel $level = null): ProgramSubject
{
    return makeProgramSubject($name, RequirementType::Mandatory, $level);
}

function makeElectiveSubject(SubjectName $name): ProgramSubject
{
    return makeProgramSubject($name, RequirementType::Elective);
}
```

Write these test cases:

1. `it('returns the mandatory subject name')` — create Program with makeMandatorySubject(Mathematics) + makeElectiveSubject(Physics), set relation, assert getMandatorySubject() returns SubjectName::Mathematics.

2. `it('returns elective subject names as array')` — create Program with makeMandatorySubject(Mathematics) + makeElectiveSubject(Physics) + makeElectiveSubject(Biology), assert getElectiveSubjects() returns `[SubjectName::Physics, SubjectName::Biology]`.

3. `it('returns null when mandatory subject has no required level')` — create Program with makeMandatorySubject(Mathematics, null), assert getMandatorySubjectLevel() is null.

4. `it('returns the required level when mandatory subject specifies one')` — create Program with makeMandatorySubject(EnglishLanguage, ExamLevel::Advanced), assert getMandatorySubjectLevel() returns ExamLevel::Advanced.

5. `it('throws UnknownProgramException when no mandatory subject exists')` — create Program with only makeElectiveSubject(Physics), assert getMandatorySubject() throws UnknownProgramException.

Each test creates a `$program = new Program()`, calls `$program->setRelation('subjects', Collection::make([...]))`, instantiates `new DatabaseProgramRequirements($program)`, and asserts the expected return.

For the exception test, use Pest syntax:
```php
expect(fn () => $requirements->getMandatorySubject())
    ->toThrow(UnknownProgramException::class);
```

**ProgramRegistryTest** (`tests/Unit/Services/ProgramRegistryTest.php`):

Replace scaffolded content. Add `declare(strict_types=1)`. Import: `App\Contracts\ProgramRequirementsInterface`, `App\Models\Applicant`, `App\Models\Program`, `App\Services\DatabaseProgramRequirements`, `App\Services\ProgramRegistry`, `Illuminate\Database\Eloquent\Collection`.

Write one test case:

1. `it('returns DatabaseProgramRequirements for an applicant')` — create `$program = new Program()`, set `$program->setRelation('subjects', Collection::make([]))`. Create `$applicant = new Applicant()`, set `$applicant->setRelation('program', $program)`. Instantiate `$registry = new ProgramRegistry()`, call `$result = $registry->findByApplicant($applicant)`. Assert:
```php
expect($result)
    ->toBeInstanceOf(DatabaseProgramRequirements::class)
    ->toBeInstanceOf(ProgramRequirementsInterface::class);
```

After creating both test files, run:
```bash
vendor/bin/pint --dirty --format agent
```

Then run the tests:
```bash
php artisan test --compact --filter=Services
```

All 6 tests must pass. If any test fails due to Collection::firstWhere/where enum comparison (returns null when it should match), go back to Task 1 and switch DatabaseProgramRequirements to use closure-based filtering:
- `->first(fn (ProgramSubject $subject): bool => $subject->requirement_type === RequirementType::Mandatory)` instead of `->firstWhere('requirement_type', RequirementType::Mandatory)`
- `->filter(fn (ProgramSubject $subject): bool => $subject->requirement_type === RequirementType::Elective)` instead of `->where('requirement_type', RequirementType::Elective)`

Then re-run tests until all pass.

After tests pass, run the full test suite to ensure no regressions:
```bash
php artisan test --compact
```
  </action>
  <verify>
    <automated>php artisan test --compact --filter=Services</automated>
  </verify>
  <done>DatabaseProgramRequirementsTest has 5 tests: mandatory subject name, elective subjects array, null mandatory level, advanced mandatory level, and unknown program exception. ProgramRegistryTest has 1 test: findByApplicant returns correct type. All 6 tests pass. Full test suite shows no regressions. Pint passes.</done>
</task>

</tasks>

<verification>
Run these checks after both tasks complete:

1. `php artisan test --compact --filter=Services` — 6 tests pass (5 DatabaseProgramRequirements + 1 ProgramRegistry)
2. `php artisan test --compact` — full suite green, no regressions
3. `vendor/bin/pint --dirty --format agent` — no changes needed
4. `php -l app/Contracts/ProgramRequirementsInterface.php` — no syntax errors
5. `php -l app/Services/DatabaseProgramRequirements.php` — no syntax errors
6. `php -l app/Services/ProgramRegistry.php` — no syntax errors
7. Verify `DatabaseProgramRequirements` is `final readonly class` implementing `ProgramRequirementsInterface`
8. Verify `getMandatorySubject()` throws `UnknownProgramException` when no mandatory subject found
9. Verify `getElectiveSubjects()` returns `array<int, SubjectName>` (not Collection)
10. Verify unit tests use `setAttribute()`/`setRelation()` only — no DB access, no factory calls, no Mockery mocks of final classes
</verification>

<success_criteria>
- ProgramRequirementsInterface exists with three method signatures and correct PHPDoc array type annotation
- DatabaseProgramRequirements is final readonly, implements the interface, filters subjects by RequirementType, throws UnknownProgramException for missing mandatory subject
- ProgramRegistry has findByApplicant() returning ProgramRequirementsInterface
- 6 unit tests pass without database access (real model instances with setAttribute/setRelation)
- Full test suite green with no regressions
- Pint passes on all new files
</success_criteria>

<output>
After completion, create `.planning/phases/05-strategy-pattern/05-01-SUMMARY.md`
</output>
